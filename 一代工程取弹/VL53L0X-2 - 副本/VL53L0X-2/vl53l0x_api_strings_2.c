/*******************************************************************************
 Copyright © 2016, STMicroelectronics International N.V.
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in the
 documentation and/or other materials provided with the distribution.
 * Neither the name of STMicroelectronics nor the
 names of its contributors may be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
 NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
 IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

#include "vl53l0x_api_2.h"
#include "vl53l0x_api_core_2.h"
#include "vl53l0x_api_strings_2.h"

#ifndef __KERNEL__
#include <stdlib.h>
#endif

#define LOG_FUNCTION_START_2(fmt, ...) \
	_LOG_FUNCTION_START_2(TRACE_MODULE_API, fmt, ##__VA_ARGS__)
#define LOG_FUNCTION_END_2(status, ...) \
	_LOG_FUNCTION_END_2(TRACE_MODULE_API, status, ##__VA_ARGS__)
#define LOG_FUNCTION_END_2_FMT(status, fmt, ...) \
	_LOG_FUNCTION_END_2_FMT(TRACE_MODULE_API, status, fmt, ##__VA_ARGS__)


VL53L0X_Error_2 VL53L0X_check_part_used_2(VL53L0X_DEV_2 Dev,
		uint8_t *Revision,
		VL53L0X_DeviceInfo_t_2 *pVL53L0X_DeviceInfo)
{
	VL53L0X_Error_2 Status = VL53L0X_ERROR_NONE_2;
	uint8_t ModuleIdInt;
	char *ProductId_tmp;

	LOG_FUNCTION_START_2("");

	Status = VL53L0X_get_info_from_device_2(Dev, 2);

	if (Status == VL53L0X_ERROR_NONE_2) {
		ModuleIdInt = VL53L0X_GETDEVICESPECIFICPARAMETER_2(Dev, ModuleId);

	if (ModuleIdInt == 0) {
		*Revision = 0;
		VL53L0X_COPYSTRING_2(pVL53L0X_DeviceInfo->ProductId, "");
	} else {
		*Revision = VL53L0X_GETDEVICESPECIFICPARAMETER_2(Dev, Revision);
		ProductId_tmp = VL53L0X_GETDEVICESPECIFICPARAMETER_2(Dev,
			ProductId);
		VL53L0X_COPYSTRING_2(pVL53L0X_DeviceInfo->ProductId, ProductId_tmp);
	}
	}

	LOG_FUNCTION_END_2(Status);
	return Status;
}


VL53L0X_Error_2 VL53L0X_get_device_info_2(VL53L0X_DEV_2 Dev,
				VL53L0X_DeviceInfo_t_2 *pVL53L0X_DeviceInfo)
{
	VL53L0X_Error_2 Status = VL53L0X_ERROR_NONE_2;
	uint8_t revision_id;
	uint8_t Revision;

	Status = VL53L0X_check_part_used_2(Dev, &Revision, pVL53L0X_DeviceInfo);

	if (Status == VL53L0X_ERROR_NONE_2) {
		if (Revision == 0) {
			VL53L0X_COPYSTRING_2(pVL53L0X_DeviceInfo->Name,
					VL53L0X_STRING_DEVICE_INFO_NAME_TS0);
		} else if ((Revision <= 34) && (Revision != 32)) {
			VL53L0X_COPYSTRING_2(pVL53L0X_DeviceInfo->Name,
					VL53L0X_STRING_DEVICE_INFO_NAME_TS1);
		} else if (Revision < 39) {
			VL53L0X_COPYSTRING_2(pVL53L0X_DeviceInfo->Name,
					VL53L0X_STRING_DEVICE_INFO_NAME_TS2);
		} else {
			VL53L0X_COPYSTRING_2(pVL53L0X_DeviceInfo->Name,
					VL53L0X_STRING_DEVICE_INFO_NAME_ES1);
		}

		VL53L0X_COPYSTRING_2(pVL53L0X_DeviceInfo->Type,
				VL53L0X_STRING_DEVICE_INFO_TYPE);

	}

	if (Status == VL53L0X_ERROR_NONE_2) {
		Status = VL53L0X_RdByte_2(Dev, VL53L0X_REG_IDENTIFICATION_MODEL_ID_2,
				&pVL53L0X_DeviceInfo->ProductType_2);
	}

	if (Status == VL53L0X_ERROR_NONE_2) {
		Status = VL53L0X_RdByte_2(Dev,
			VL53L0X_REG_IDENTIFICATION_REVISION_ID_2,
				&revision_id);
		pVL53L0X_DeviceInfo->ProductRevisionMajor_2 = 1;
		pVL53L0X_DeviceInfo->ProductRevisionMinor_2 =
					(revision_id & 0xF0) >> 4;
	}

	return Status;
}


VL53L0X_Error_2 VL53L0X_get_device_error_string_2(VL53L0X_DeviceError_2 ErrorCode,
		char *pDeviceErrorString)
{
	VL53L0X_Error_2 Status = VL53L0X_ERROR_NONE_2;

	LOG_FUNCTION_START_2("");

	switch (ErrorCode) {
	case VL53L0X_DEVICEERROR_NONE_2:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_DEVICEERROR_NONE);
	break;
	case VL53L0X_DEVICEERROR_VCSELCONTINUITYTESTFAILURE_2:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_DEVICEERROR_VCSELCONTINUITYTESTFAILURE);
	break;
	case VL53L0X_DEVICEERROR_VCSELWATCHDOGTESTFAILURE_2:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_DEVICEERROR_VCSELWATCHDOGTESTFAILURE);
	break;
	case VL53L0X_DEVICEERROR_NOVHVVALUEFOUND_2:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_DEVICEERROR_NOVHVVALUEFOUND);
	break;

	case VL53L0X_DEVICEERROR_MSRCNOTARGET_2:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_DEVICEERROR_MSRCNOTARGET);
	break;
	case VL53L0X_DEVICEERROR_SNRCHECK_2:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_DEVICEERROR_SNRCHECK);
	break;
	case VL53L0X_DEVICEERROR_RANGEPHASECHECK_2:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_DEVICEERROR_RANGEPHASECHECK);
	break;
	case VL53L0X_DEVICEERROR_SIGMATHRESHOLDCHECK_2:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_DEVICEERROR_SIGMATHRESHOLDCHECK);
	break;
	case VL53L0X_DEVICEERROR_TCC_2:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_DEVICEERROR_TCC);
	break;
	case VL53L0X_DEVICEERROR_PHASECONSISTENCY_2:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_DEVICEERROR_PHASECONSISTENCY);
	break;
	case VL53L0X_DEVICEERROR_MINCLIP_2:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_DEVICEERROR_MINCLIP);
	break;
	case VL53L0X_DEVICEERROR_RANGECOMPLETE_2:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_DEVICEERROR_RANGECOMPLETE);
	break;
	case VL53L0X_DEVICEERROR_ALGOUNDERFLOW_2:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_DEVICEERROR_ALGOUNDERFLOW);
	break;
	case VL53L0X_DEVICEERROR_ALGOOVERFLOW_2:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_DEVICEERROR_ALGOOVERFLOW);
	break;
	case VL53L0X_DEVICEERROR_RANGEIGNORETHRESHOLD_2:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_DEVICEERROR_RANGEIGNORETHRESHOLD);
	break;

	default:
		VL53L0X_COPYSTRING_2(pDeviceErrorString,
			VL53L0X_STRING_UNKNOW_ERROR_CODE);

	}

	LOG_FUNCTION_END_2(Status);
	return Status;
}

VL53L0X_Error_2 VL53L0X_get_range_status_string_2(uint8_t RangeStatus,
		char *pRangeStatusString)
{
	VL53L0X_Error_2 Status = VL53L0X_ERROR_NONE_2;

	LOG_FUNCTION_START_2("");

	switch (RangeStatus) {
	case 0:
		VL53L0X_COPYSTRING_2(pRangeStatusString,
			VL53L0X_STRING_RANGESTATUS_RANGEVALID);
	break;
	case 1:
		VL53L0X_COPYSTRING_2(pRangeStatusString,
			VL53L0X_STRING_RANGESTATUS_SIGMA);
	break;
	case 2:
		VL53L0X_COPYSTRING_2(pRangeStatusString,
			VL53L0X_STRING_RANGESTATUS_SIGNAL);
	break;
	case 3:
		VL53L0X_COPYSTRING_2(pRangeStatusString,
			VL53L0X_STRING_RANGESTATUS_MINRANGE);
	break;
	case 4:
		VL53L0X_COPYSTRING_2(pRangeStatusString,
			VL53L0X_STRING_RANGESTATUS_PHASE);
	break;
	case 5:
		VL53L0X_COPYSTRING_2(pRangeStatusString,
			VL53L0X_STRING_RANGESTATUS_HW);
	break;

	default: /**/
		VL53L0X_COPYSTRING_2(pRangeStatusString,
				VL53L0X_STRING_RANGESTATUS_NONE);
	}

	LOG_FUNCTION_END_2(Status);
	return Status;
}

VL53L0X_Error_2 VL53L0X_get_pal_error_string_2(VL53L0X_Error_2 PalErrorCode,
		char *pPalErrorString)
{
	VL53L0X_Error_2 Status = VL53L0X_ERROR_NONE_2;

	LOG_FUNCTION_START_2("");

	switch (PalErrorCode) {
	case VL53L0X_ERROR_NONE_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_NONE);
	break;
	case VL53L0X_ERROR_CALIBRATION_WARNING_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_CALIBRATION_WARNING);
	break;
	case VL53L0X_ERROR_MIN_CLIPPED_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_MIN_CLIPPED);
	break;
	case VL53L0X_ERROR_UNDEFINED_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_UNDEFINED);
	break;
	case VL53L0X_ERROR_INVALID_PARAMS_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_INVALID_PARAMS);
	break;
	case VL53L0X_ERROR_NOT_SUPPORTED_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_NOT_SUPPORTED);
	break;
	case VL53L0X_ERROR_INTERRUPT_NOT_CLEARED_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_INTERRUPT_NOT_CLEARED);
	break;
	case VL53L0X_ERROR_RANGE_ERROR_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_RANGE_ERROR);
	break;
	case VL53L0X_ERROR_TIME_OUT_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_TIME_OUT);
	break;
	case VL53L0X_ERROR_MODE_NOT_SUPPORTED_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_MODE_NOT_SUPPORTED);
	break;
	case VL53L0X_ERROR_BUFFER_TOO_SMALL_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_BUFFER_TOO_SMALL);
	break;
	case VL53L0X_ERROR_GPIO_NOT_EXISTING_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_GPIO_NOT_EXISTING);
	break;
	case VL53L0X_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED);
	break;
	case VL53L0X_ERROR_CONTROL_INTERFACE_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_CONTROL_INTERFACE);
	break;
	case VL53L0X_ERROR_INVALID_COMMAND_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_INVALID_COMMAND);
	break;
	case VL53L0X_ERROR_DIVISION_BY_ZERO_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_DIVISION_BY_ZERO);
	break;
	case VL53L0X_ERROR_REF_SPAD_INIT_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_REF_SPAD_INIT);
	break;
	case VL53L0X_ERROR_NOT_IMPLEMENTED_2:
		VL53L0X_COPYSTRING_2(pPalErrorString,
			VL53L0X_STRING_ERROR_NOT_IMPLEMENTED);
	break;

	default:
		VL53L0X_COPYSTRING_2(pPalErrorString,
				VL53L0X_STRING_UNKNOW_ERROR_CODE);
	}

	LOG_FUNCTION_END_2(Status);
	return Status;
}

VL53L0X_Error_2 VL53L0X_get_pal_state_string_2(VL53L0X_State_2 PalStateCode,
		char *pPalStateString)
{
	VL53L0X_Error_2 Status = VL53L0X_ERROR_NONE_2;

	LOG_FUNCTION_START_2("");

	switch (PalStateCode) {
	case VL53L0X_STATE_POWERDOWN_2:
		VL53L0X_COPYSTRING_2(pPalStateString,
			VL53L0X_STRING_STATE_POWERDOWN);
	break;
	case VL53L0X_STATE_WAIT_STATICINIT_2:
		VL53L0X_COPYSTRING_2(pPalStateString,
			VL53L0X_STRING_STATE_WAIT_STATICINIT);
	break;
	case VL53L0X_STATE_STANDBY_2:
		VL53L0X_COPYSTRING_2(pPalStateString,
			VL53L0X_STRING_STATE_STANDBY);
	break;
	case VL53L0X_STATE_IDLE_2:
		VL53L0X_COPYSTRING_2(pPalStateString,
			VL53L0X_STRING_STATE_IDLE);
	break;
	case VL53L0X_STATE_RUNNING_2:
		VL53L0X_COPYSTRING_2(pPalStateString,
			VL53L0X_STRING_STATE_RUNNING);
	break;
	case VL53L0X_STATE_UNKNOWN_2:
		VL53L0X_COPYSTRING_2(pPalStateString,
			VL53L0X_STRING_STATE_UNKNOWN);
	break;
	case VL53L0X_STATE_ERROR_2:
		VL53L0X_COPYSTRING_2(pPalStateString,
			VL53L0X_STRING_STATE_ERROR);
	break;

	default:
		VL53L0X_COPYSTRING_2(pPalStateString,
			VL53L0X_STRING_STATE_UNKNOWN);
	}

	LOG_FUNCTION_END_2(Status);
	return Status;
}

VL53L0X_Error_2 VL53L0X_get_sequence_steps_info_2(
		VL53L0X_SequenceStepId_2 SequenceStepId,
		char *pSequenceStepsString)
{
	VL53L0X_Error_2 Status = VL53L0X_ERROR_NONE_2;
	LOG_FUNCTION_START_2("");

	switch (SequenceStepId) {
	case VL53L0X_SEQUENCESTEP_TCC_2:
		VL53L0X_COPYSTRING_2(pSequenceStepsString,
			VL53L0X_STRING_SEQUENCESTEP_TCC);
	break;
	case VL53L0X_SEQUENCESTEP_DSS_2:
		VL53L0X_COPYSTRING_2(pSequenceStepsString,
			VL53L0X_STRING_SEQUENCESTEP_DSS);
	break;
	case VL53L0X_SEQUENCESTEP_MSRC_2:
		VL53L0X_COPYSTRING_2(pSequenceStepsString,
			VL53L0X_STRING_SEQUENCESTEP_MSRC);
	break;
	case VL53L0X_SEQUENCESTEP_PRE_RANGE_2:
		VL53L0X_COPYSTRING_2(pSequenceStepsString,
			VL53L0X_STRING_SEQUENCESTEP_PRE_RANGE);
	break;
	case VL53L0X_SEQUENCESTEP_FINAL_RANGE_2:
		VL53L0X_COPYSTRING_2(pSequenceStepsString,
			VL53L0X_STRING_SEQUENCESTEP_FINAL_RANGE);
	break;

	default:
		Status = VL53L0X_ERROR_INVALID_PARAMS_2;
	}

	LOG_FUNCTION_END_2(Status);

	return Status;
}


VL53L0X_Error_2 VL53L0X_get_limit_check_info_2(VL53L0X_DEV_2 Dev, uint16_t LimitCheckId,
	char *pLimitCheckString)
{
	VL53L0X_Error_2 Status = VL53L0X_ERROR_NONE_2;

	LOG_FUNCTION_START_2("");

	switch (LimitCheckId) {
	case VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE_2:
		VL53L0X_COPYSTRING_2(pLimitCheckString,
			VL53L0X_STRING_CHECKENABLE_SIGMA_FINAL_RANGE);
	break;
	case VL53L0X_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE_2:
		VL53L0X_COPYSTRING_2(pLimitCheckString,
			VL53L0X_STRING_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE);
	break;
	case VL53L0X_CHECKENABLE_SIGNAL_REF_CLIP_2:
		VL53L0X_COPYSTRING_2(pLimitCheckString,
			VL53L0X_STRING_CHECKENABLE_SIGNAL_REF_CLIP);
	break;
	case VL53L0X_CHECKENABLE_RANGE_IGNORE_THRESHOLD_2:
		VL53L0X_COPYSTRING_2(pLimitCheckString,
			VL53L0X_STRING_CHECKENABLE_RANGE_IGNORE_THRESHOLD);
	break;

	case VL53L0X_CHECKENABLE_SIGNAL_RATE_MSRC_2:
		VL53L0X_COPYSTRING_2(pLimitCheckString,
			VL53L0X_STRING_CHECKENABLE_SIGNAL_RATE_MSRC);
	break;

	case VL53L0X_CHECKENABLE_SIGNAL_RATE_PRE_RANGE_2:
		VL53L0X_COPYSTRING_2(pLimitCheckString,
			VL53L0X_STRING_CHECKENABLE_SIGNAL_RATE_PRE_RANGE);
	break;

	default:
		VL53L0X_COPYSTRING_2(pLimitCheckString,
			VL53L0X_STRING_UNKNOW_ERROR_CODE);

	}

	LOG_FUNCTION_END_2(Status);
	return Status;
}
